var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,"name",{value,configurable:!0});var NOT_FOUND=Symbol("NOT_FOUND");function assertIsFunction(func,errorMessage=`expected a function, instead received ${typeof func}`){if(typeof func!="function")throw new TypeError(errorMessage)}__name(assertIsFunction,"assertIsFunction");function assertIsObject(object,errorMessage=`expected an object, instead received ${typeof object}`){if(typeof object!="object")throw new TypeError(errorMessage)}__name(assertIsObject,"assertIsObject");function assertIsArrayOfFunctions(array,errorMessage="expected all items to be functions, instead received the following types: "){if(!array.every(item=>typeof item=="function")){const itemTypes=array.map(item=>typeof item=="function"?`function ${item.name||"unnamed"}()`:typeof item).join(", ");throw new TypeError(`${errorMessage}[${itemTypes}]`)}}__name(assertIsArrayOfFunctions,"assertIsArrayOfFunctions");var ensureIsArray=__name(item=>Array.isArray(item)?item:[item],"ensureIsArray");function getDependencies(createSelectorArgs){const dependencies=Array.isArray(createSelectorArgs[0])?createSelectorArgs[0]:createSelectorArgs;return assertIsArrayOfFunctions(dependencies,"createSelector expects all input-selectors to be functions, but received the following types: "),dependencies}__name(getDependencies,"getDependencies");function collectInputSelectorResults(dependencies,inputSelectorArgs){const inputSelectorResults=[],{length}=dependencies;for(let i=0;i<length;i++)inputSelectorResults.push(dependencies[i].apply(null,inputSelectorArgs));return inputSelectorResults}__name(collectInputSelectorResults,"collectInputSelectorResults");function createSingletonCache(equals){let entry;return{get(key){return entry&&equals(entry.key,key)?entry.value:NOT_FOUND},put(key,value){entry={key,value}},getEntries(){return entry?[entry]:[]},clear(){entry=void 0}}}__name(createSingletonCache,"createSingletonCache");function createLruCache(maxSize,equals){let entries=[];function get(key){const cacheIndex=entries.findIndex(entry=>equals(key,entry.key));if(cacheIndex>-1){const entry=entries[cacheIndex];return cacheIndex>0&&(entries.splice(cacheIndex,1),entries.unshift(entry)),entry.value}return NOT_FOUND}__name(get,"get");function put(key,value){get(key)===NOT_FOUND&&(entries.unshift({key,value}),entries.length>maxSize&&entries.pop())}__name(put,"put");function getEntries(){return entries}__name(getEntries,"getEntries");function clear(){entries=[]}return __name(clear,"clear"),{get,put,getEntries,clear}}__name(createLruCache,"createLruCache");var referenceEqualityCheck=__name((a,b)=>a===b,"referenceEqualityCheck");function createCacheKeyComparator(equalityCheck){return __name(function(prev,next){if(prev===null||next===null||prev.length!==next.length)return!1;const{length}=prev;for(let i=0;i<length;i++)if(!equalityCheck(prev[i],next[i]))return!1;return!0},"areArgumentsShallowlyEqual")}__name(createCacheKeyComparator,"createCacheKeyComparator");function lruMemoize(func,equalityCheckOrOptions){const providedOptions=typeof equalityCheckOrOptions=="object"?equalityCheckOrOptions:{equalityCheck:equalityCheckOrOptions},{equalityCheck=referenceEqualityCheck,maxSize=1,resultEqualityCheck}=providedOptions,comparator=createCacheKeyComparator(equalityCheck);let resultsCount=0;const cache=maxSize<=1?createSingletonCache(comparator):createLruCache(maxSize,comparator);function memoized(){let value=cache.get(arguments);if(value===NOT_FOUND){if(value=func.apply(null,arguments),resultsCount++,resultEqualityCheck){const matchingEntry=cache.getEntries().find(entry=>resultEqualityCheck(entry.value,value));matchingEntry&&(value=matchingEntry.value,resultsCount!==0&&resultsCount--)}cache.put(arguments,value)}return value}return __name(memoized,"memoized"),memoized.clearCache=()=>{cache.clear(),memoized.resetResultsCount()},memoized.resultsCount=()=>resultsCount,memoized.resetResultsCount=()=>{resultsCount=0},memoized}__name(lruMemoize,"lruMemoize");var _a,StrongRef=(_a=class{constructor(value){this.value=value}deref(){return this.value}},__name(_a,"StrongRef"),_a),Ref=typeof WeakRef<"u"?WeakRef:StrongRef,UNTERMINATED=0,TERMINATED=1;function createCacheNode(){return{s:UNTERMINATED,v:void 0,o:null,p:null}}__name(createCacheNode,"createCacheNode");function weakMapMemoize(func,options={}){let fnNode=createCacheNode();const{resultEqualityCheck}=options;let lastResult,resultsCount=0;function memoized(){var _a2;let cacheNode=fnNode;const{length}=arguments;for(let i=0,l=length;i<l;i++){const arg=arguments[i];if(typeof arg=="function"||typeof arg=="object"&&arg!==null){let objectCache=cacheNode.o;objectCache===null&&(cacheNode.o=objectCache=new WeakMap);const objectNode=objectCache.get(arg);objectNode===void 0?(cacheNode=createCacheNode(),objectCache.set(arg,cacheNode)):cacheNode=objectNode}else{let primitiveCache=cacheNode.p;primitiveCache===null&&(cacheNode.p=primitiveCache=new Map);const primitiveNode=primitiveCache.get(arg);primitiveNode===void 0?(cacheNode=createCacheNode(),primitiveCache.set(arg,cacheNode)):cacheNode=primitiveNode}}const terminatedNode=cacheNode;let result;if(cacheNode.s===TERMINATED)result=cacheNode.v;else if(result=func.apply(null,arguments),resultsCount++,resultEqualityCheck){const lastResultValue=((_a2=lastResult==null?void 0:lastResult.deref)==null?void 0:_a2.call(lastResult))??lastResult;lastResultValue!=null&&resultEqualityCheck(lastResultValue,result)&&(result=lastResultValue,resultsCount!==0&&resultsCount--),lastResult=typeof result=="object"&&result!==null||typeof result=="function"?new Ref(result):result}return terminatedNode.s=TERMINATED,terminatedNode.v=result,result}return __name(memoized,"memoized"),memoized.clearCache=()=>{fnNode=createCacheNode(),memoized.resetResultsCount()},memoized.resultsCount=()=>resultsCount,memoized.resetResultsCount=()=>{resultsCount=0},memoized}__name(weakMapMemoize,"weakMapMemoize");function createSelectorCreator(memoizeOrOptions,...memoizeOptionsFromArgs){const createSelectorCreatorOptions=typeof memoizeOrOptions=="function"?{memoize:memoizeOrOptions,memoizeOptions:memoizeOptionsFromArgs}:memoizeOrOptions,createSelector2=__name((...createSelectorArgs)=>{let recomputations=0,dependencyRecomputations=0,lastResult,directlyPassedOptions={},resultFunc=createSelectorArgs.pop();typeof resultFunc=="object"&&(directlyPassedOptions=resultFunc,resultFunc=createSelectorArgs.pop()),assertIsFunction(resultFunc,`createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`);const combinedOptions={...createSelectorCreatorOptions,...directlyPassedOptions},{memoize,memoizeOptions=[],argsMemoize=weakMapMemoize,argsMemoizeOptions=[]}=combinedOptions,finalMemoizeOptions=ensureIsArray(memoizeOptions),finalArgsMemoizeOptions=ensureIsArray(argsMemoizeOptions),dependencies=getDependencies(createSelectorArgs),memoizedResultFunc=memoize(__name(function(){return recomputations++,resultFunc.apply(null,arguments)},"recomputationWrapper"),...finalMemoizeOptions),selector=argsMemoize(__name(function(){dependencyRecomputations++;const inputSelectorResults=collectInputSelectorResults(dependencies,arguments);return lastResult=memoizedResultFunc.apply(null,inputSelectorResults),lastResult},"dependenciesChecker"),...finalArgsMemoizeOptions);return Object.assign(selector,{resultFunc,memoizedResultFunc,dependencies,dependencyRecomputations:__name(()=>dependencyRecomputations,"dependencyRecomputations"),resetDependencyRecomputations:__name(()=>{dependencyRecomputations=0},"resetDependencyRecomputations"),lastResult:__name(()=>lastResult,"lastResult"),recomputations:__name(()=>recomputations,"recomputations"),resetRecomputations:__name(()=>{recomputations=0},"resetRecomputations"),memoize,argsMemoize})},"createSelector2");return Object.assign(createSelector2,{withTypes:__name(()=>createSelector2,"withTypes")}),createSelector2}__name(createSelectorCreator,"createSelectorCreator");var createSelector=createSelectorCreator(weakMapMemoize),createStructuredSelector=Object.assign((inputSelectorsObject,selectorCreator=createSelector)=>{assertIsObject(inputSelectorsObject,`createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`);const inputSelectorKeys=Object.keys(inputSelectorsObject),dependencies=inputSelectorKeys.map(key=>inputSelectorsObject[key]);return selectorCreator(dependencies,(...inputSelectorResults)=>inputSelectorResults.reduce((composition,value,index)=>(composition[inputSelectorKeys[index]]=value,composition),{}))},{withTypes:__name(()=>createStructuredSelector,"withTypes")});export{createSelectorCreator as c,lruMemoize as l};
//# sourceMappingURL=reselect-CDQ-Ks90.js.map
